{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#about-taxopy","title":"About <code>taxopy</code>","text":"<p><code>taxopy</code> is a Python package that provides an interface for assessing NCBI-formatted taxonomic databases. It enables various operations on taxonomic data, such as obtaining complete lineages, determining the lowest common ancestors (LCAs), retrieving taxa names from taxonomic identifiers, and more.</p>"},{"location":"#installation","title":"Installation","text":"<p>You can install <code>taxopy</code> on your computer using Python's <code>pip</code>, <code>uv</code>, or through the <code>pixi</code>, <code>conda</code> or <code>mamba</code> package managers:</p> pipuvPixiCondaMamba <pre><code>$ pip install taxopy\n</code></pre> <pre><code>$ uv init example\n$ cd example\n$ uv add taxopy\n</code></pre> <pre><code>$ pixi init --channel conda-forge --channel bioconda example\n$ cd example\n$ pixi add taxopy\n</code></pre> <pre><code>$ conda create -n taxopy-env -c conda-forge -c bioconda taxopy\n$ conda activate taxopy-env\n</code></pre> <pre><code>$ mamba create -n taxopy-env -c conda-forge -c bioconda taxopy\n$ mamba activate taxopy-env\n</code></pre> <p>Enabling fuzzy search of taxon names</p> <p><code>taxopy</code> supports fuzzy string matching to search for taxa with names that are similar but not identical to the queries. This feature is not enabled by default to avoid additional dependencies. However, you can enable it by installing the <code>fuzzy-matching</code> extra using <code>pip</code> or <code>uv</code>:</p> pipuv <pre><code>$ pip install taxopy[fuzzy-matching]\n</code></pre> <pre><code>$ uv init example\n$ cd example\n$ uv add taxopy --extra fuzzy-matching\n</code></pre> <p>Alternatively, you can install the <code>rapidfuzz</code> library alongside <code>taxopy</code>:</p> pipuvPixiCondaMamba <pre><code>$ pip install taxopy rapidfuzz\n</code></pre> <pre><code>$ uv init example\n$ cd example\n$ uv add taxopy rapidfuzz\n</code></pre> <pre><code>$ pixi init --channel conda-forge --channel bioconda example\n$ cd example\n$ pixi add taxopy rapidfuzz\n</code></pre> <pre><code>$ conda create -n taxopy-env -c conda-forge -c bioconda taxopy rapidfuzz\n$ conda activate taxopy-env\n</code></pre> <pre><code>$ mamba create -n taxopy-env -c conda-forge -c bioconda taxopy rapidfuzz\n$ mamba activate taxopy-env\n</code></pre>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>Some of the code used to parse taxdump files in <code>taxopy</code> was adapted from CAT/BAT<sup>1</sup>, a tool for taxonomic assignment of contigs and metagenome-assembled genomes.</p> <ol> <li> <p>Von Meijenfeldt, F. A. B., Arkhipova, K., Cambuy, D. D., Coutinho, F. H. &amp; Dutilh, B. E. \"Robust taxonomic classification of uncharted microbial sequences and bins with CAT and BAT\". Genome Biology 20, 217 (2019).\u00a0\u21a9</p> </li> </ol>"},{"location":"guide/","title":"Guide","text":""},{"location":"guide/#initializing-a-taxonomy-database-in-a-taxdb-object","title":"Initializing a taxonomy database in a <code>TaxDb</code> object","text":"<p>To get started, you need to create a <code>TaxDb</code> object, which will store data related to the taxonomic database, such as taxonomic identifiers (or TaxIds), names, and hierarchies. This can be achieved by downloading the set of files that store this data, known as taxdump, from an online source (NCBI by default) or by providing your own taxdump files.</p> Downloading from NCBIDownloading from a different sourceLocal taxdump <pre><code>&gt;&gt;&gt; import taxopy\n&gt;&gt;&gt; taxdb = taxopy.TaxDb()# (1)!\n</code></pre> <ol> <li>By default, <code>taxopy</code> deletes the taxdump files after creating the object. To retain the files in the working directory, set <code>keep_files=True</code>. You can specify the directory where the files are stored using the <code>taxdb_dir</code> parameter.</li> </ol> <pre><code>&gt;&gt;&gt; import taxopy\n&gt;&gt;&gt; url = \"https://github.com/shenwei356/gtdb-taxdump/releases/download/v0.5.0/gtdb-taxdump-R220.tar.gz\"\n&gt;&gt;&gt; taxdb = taxopy.TaxDb(\n...     taxdump_url=url# (1)!\n... )\n</code></pre> <ol> <li>The <code>taxdump_url</code> parameter is used to specify the URL of the taxdump file to download. In this case, we are using a custom a GTDB taxdump provided by Wei Shen.</li> </ol> <pre><code>&gt;&gt;&gt; import taxopy\n&gt;&gt;&gt; taxdb = taxopy.TaxDb(\n...     nodes_dmp=\"taxdb/nodes.dmp\",\n...     names_dmp=\"taxdb/names.dmp\",\n...     merged_dmp=\"taxdb/merged.dmp\",# (1)!\n... )\n</code></pre> <ol> <li>The <code>merged_dmp</code> parameter is optional. However, if you want to support legacy TaxIds (those merged into other identifiers), you need to provide a <code>merged.dmp</code> file. This is not necessary if the data is downloaded from an online source, which will include its own merged.dmp file.</li> </ol> <p>The <code>TaxDb</code> object stores the names, ranks, and parent-child relationships of all taxa, each represented by their respective TaxIds. For instance, TaxId 2 corresponds to the \"Bacteria\" taxon, which has the rank of superkingdom. The parent taxon of Bacteria is TaxId 131567, corresponding to \"cellular organisms\".</p> <pre><code>&gt;&gt;&gt; print(taxdb.taxid2name[2])\nBacteria\n&gt;&gt;&gt; print(taxdb.taxid2rank[2])\nsuperkingdom\n&gt;&gt;&gt; print(taxdb.taxid2parent[2])\n131567\n</code></pre> <p>To retrieve the TaxId to which a legacy TaxId has been merged, you can use the <code>oldtaxid2newtaxid</code> attribute. For instance, the legacy TaxIds 260 and 29537 have been merged into TaxId 143224 (\"Zobellia uliginosa\").</p> <pre><code>&gt;&gt;&gt; print(taxdb.oldtaxid2newtaxid[260])\n143224\n&gt;&gt;&gt; print(taxdb.oldtaxid2newtaxid[29537])\n143224\n</code></pre>"},{"location":"guide/#the-taxon-object","title":"The <code>Taxon</code> object","text":"<p><code>Taxon</code> objects represent individual taxa within the taxonomy database. These objects are initialized using a TaxId and a corresponding <code>TaxDb</code> object, from which the taxon data is retrieved.</p> <pre><code>&gt;&gt;&gt; saccharomyces = taxopy.Taxon(4930, taxdb)\n&gt;&gt;&gt; human = taxopy.Taxon(9606, taxdb)\n&gt;&gt;&gt; gorilla = taxopy.Taxon(9593, taxdb)\n&gt;&gt;&gt; lagomorpha = taxopy.Taxon(9975, taxdb)\n</code></pre> <p>Each <code>Taxon</code> object stores various data related to the taxon, including its TaxId, names, rank, and lineage. The lineage data comprises the TaxIds, scientific names, and ranks of its parent taxa.</p> <pre><code>&gt;&gt;&gt; print(lagomorpha.taxid)\n9975\n&gt;&gt;&gt; print(lagomorpha.taxid_lineage)\n[9975, 314147, 314146, 1437010, 9347, 32525, 40674, 32524, 32523, 1338369, 8287, 117571, 117570, 7776, 7742, 89593, 7711, 33511, 33213, 6072, 33208, 33154, 2759, 131567, 1]\n&gt;&gt;&gt; print(lagomorpha.ranked_taxid_lineage)\n[('order', 9975), ('clade', 314147), ('superorder', 314146), ('clade', 1437010), ('clade', 9347), ('clade', 32525), ('class', 40674), ('clade', 32524), ('clade', 32523), ('clade', 1338369), ('superclass', 8287), ('clade', 117571), ('clade', 117570), ('clade', 7776), ('clade', 7742), ('subphylum', 89593), ('phylum', 7711), ('clade', 33511), ('clade', 33213), ('clade', 6072), ('kingdom', 33208), ('clade', 33154), ('superkingdom', 2759), ('no rank', 131567), ('no rank', 1)]\n&gt;&gt;&gt; print(lagomorpha.name)\nLagomorpha\n&gt;&gt;&gt; print(lagomorpha.all_names)\n{'authority': ['Lagomorpha Brandt, 1855'], 'scientific name': ['Lagomorpha'], 'blast name': ['rabbits &amp; hares']}\n&gt;&gt;&gt; print(lagomorpha.name_lineage)\n['Lagomorpha', 'Glires', 'Euarchontoglires', 'Boreoeutheria', 'Eutheria', 'Theria', 'Mammalia', 'Amniota', 'Tetrapoda', 'Dipnotetrapodomorpha', 'Sarcopterygii', 'Euteleostomi', 'Teleostomi', 'Gnathostomata', 'Vertebrata', 'Craniata', 'Chordata', 'Deuterostomia', 'Bilateria', 'Eumetazoa', 'Metazoa', 'Opisthokonta', 'Eukaryota', 'cellular organisms', 'root']\n&gt;&gt;&gt; print(lagomorpha.ranked_name_lineage)\n[('order', 'Lagomorpha'), ('clade', 'Glires'), ('superorder', 'Euarchontoglires'), ('clade', 'Boreoeutheria'), ('clade', 'Eutheria'), ('clade', 'Theria'), ('class', 'Mammalia'), ('clade', 'Amniota'), ('clade', 'Tetrapoda'), ('clade', 'Dipnotetrapodomorpha'), ('superclass', 'Sarcopterygii'), ('clade', 'Euteleostomi'), ('clade', 'Teleostomi'), ('clade', 'Gnathostomata'), ('clade', 'Vertebrata'), ('subphylum', 'Craniata'), ('phylum', 'Chordata'), ('clade', 'Deuterostomia'), ('clade', 'Bilateria'), ('clade', 'Eumetazoa'), ('kingdom', 'Metazoa'), ('clade', 'Opisthokonta'), ('superkingdom', 'Eukaryota'), ('no rank', 'cellular organisms'), ('no rank', 'root')]\n&gt;&gt;&gt; print(lagomorpha.rank_name_dictionary)\nOrderedDict({'order': 'Lagomorpha', 'clade': 'Opisthokonta', 'superorder': 'Euarchontoglires', 'class': 'Mammalia', 'superclass': 'Sarcopterygii', 'subphylum': 'Craniata', 'phylum': 'Chordata', 'kingdom': 'Metazoa', 'superkingdom': 'Eukaryota'})\n&gt;&gt;&gt; print(lagomorpha.rank)\norder\n</code></pre> <p>A taxon's scientific name is stored in the <code>name</code> field, while <code>all_names</code> is a dictionary from the kind of name to a list of names. </p> <pre><code>&gt;&gt;&gt; sus = taxopy.Taxon(9823, taxdb)\n&gt;&gt;&gt; print(sus.name)\n'Sus scrofa'\n&gt;&gt;&gt; print(sus.all_names)\n{'genbank common name': ['pig'], 'common name': ['pigs', 'swine', 'wild boar'], 'authority': ['Sus scrofa Linnaeus, 1758'], 'includes': ['Sus scrofa LW', 'Sus scrofa Pietrain'], 'scientific name': ['Sus scrofa']}\n&gt;&gt;&gt; print(sus.all_names['common name'])\n['pigs', 'swine', 'wild boar']\n</code></pre> <p>To obtain the <code>Taxon</code> object for the parent of a specified taxon, you can use the <code>parent</code> method.</p> <pre><code>&gt;&gt;&gt; saccharomyces_parent = saccharomyces.parent(taxdb)\n&gt;&gt;&gt; print(saccharomyces_parent.name)\nSaccharomycetaceae\n&gt;&gt;&gt; print(saccharomyces_parent.rank)\nfamily\n</code></pre>"},{"location":"guide/#identifying-taxa-shared-between-multiple-lineages","title":"Identifying taxa shared between multiple lineages","text":"<p>Due to the hierarchical nature of taxonomies, different taxa may share common ancestors at one or more ranks in their lineages. For example, the Lagomorpha and Homo sapiens lineages have common taxa from the root of the taxonomy (parent to all other taxa) up until Euarchontoglires, from which they then diverge.</p> <p><pre><code>---\nconfig:\n  layout: elk\n---\ngraph LR\n    subgraph cluster [\"*Lagomorpha*, *Homo sapiens*\"]\n        R(Root) -.-&gt; E(*Euarchontoglires*)\n    end\n    E --&gt; P(*Primates*)\n    P -.-&gt; H(*Homo sapiens*)\n    E --&gt; G(*Glires*)\n    G --&gt; L(*Lagomorpha*)</code></pre> In <code>taxopy</code>, <code>Taxon</code> objects store the lineage data for each taxon, enabling the identification of shared taxa between two or more lineages. <code>taxopy</code> provides two functions for this purpose:</p> <ul> <li><code>find_lca</code>: Identifies the most specific taxon shared among all provided lineages.</li> <li><code>find_majority_vote</code>: Identifies the most specific taxon common to more than a specified fraction of the provided lineages (default is more than 50%).</li> </ul>"},{"location":"guide/#lowest-common-ancestor","title":"Lowest common ancestor","text":"<p>The lowest common ancestor (LCA) of a set of taxa is the most specific taxon that is common to all the lineages. In the example above, the LCA between Lagomorpha and Homo sapiens is the Euarchontoglires superorder. This can be easily determined using <code>taxopy</code> through the <code>find_lca</code>.</p> <pre><code>&gt;&gt;&gt; print(taxopy.find_lca([lagomorpha, human], taxdb).name)\nEuarchontoglires\n</code></pre>"},{"location":"guide/#majority-vote","title":"Majority vote","text":"<p>The LCA can be uninformative when determining a representative taxon for a set of lineages. For instance, consider the lineages of Lagomorpha, Homo sapiens, and Saccharomyces.</p> <pre><code>---\nconfig:\n  layout: elk\n---\ngraph LR\n    subgraph cluster1 [\"*Saccharomyces*, *Lagomorpha*, *Homo sapiens*\"]\n        R(Root) -.-&gt; O(*Opisthokonta*) --&gt; M(*Metazoa*)\n        subgraph cluster2 [\"*Lagomorpha*, *Homo sapiens*\"]\n            M -.-&gt; E(*Euarchontoglires*)\n        end\n    end\n    E --&gt; P(*Primates*)\n    P -.-&gt; H(*Homo sapiens*)\n    E --&gt; G(*Glires*)\n    G --&gt; L(*Lagomorpha*)\n    O --&gt; F(*Fungi*) -...-&gt; S(*Saccharomyces*)</code></pre> <p>Saccharomyces is very distantly related to both Lagomorpha and Homo sapiens, making the LCA of these three lineages Opisthokonta, a broad group within Eukaryota that includes both animals and fungi.</p> <pre><code>&gt;&gt;&gt; print(taxopy.find_lca([saccharomyces, lagomorpha, human], taxdb).name)\nOpisthokonta\n</code></pre> <p>If you want to find a taxon that represents most of the lineages in a set, the LCA might be too broad if a single distantly related organism is included, which is especially common when working with a large set of lineages. Instead, you can use the <code>find_majority_vote</code> function to determine the taxon shared by most of the lineages, but not necessarily all of them. This approach generally yields a more specific taxon than the LCA. In the example above, Euarchontoglires is the most specific taxon shared by more than half of the three lineages.</p> <pre><code>&gt;&gt;&gt; print(\n...     taxopy.find_majority_vote(\n...         [saccharomyces, lagomorpha, human], taxdb\n...     ).name\n... )\nEuarchontoglires\n</code></pre>"},{"location":"guide/#the-fraction-parameter","title":"The <code>fraction</code> parameter","text":"<p>By default, <code>find_majority_vote</code> requires the taxon to be shared by more than half of the lineages. You can adjust this threshold by setting the <code>fraction</code> parameter to a value greater than <code>0</code> and less than <code>1</code> (default is <code>0.5</code>). Higher values will require the resulting taxon to be shared by more lineages, approaching the LCA.</p> <p>Let's add Gorilla gorilla to the set of lineages we are investigating.</p> <pre><code>---\nconfig:\n  layout: elk\n---\ngraph LR\n    subgraph cluster1 [\"*Saccharomyces*, *Lagomorpha*, *Homo sapiens*, *Gorilla gorilla*\"]\n        R(Root) -.-&gt; O(*Opisthokonta*) --&gt; M(*Metazoa*)\n        subgraph cluster2 [\"*Lagomorpha*, *Homo sapiens*, *Gorilla gorilla*\"]\n            M -.-&gt; E(*Euarchontoglires*)\n            E -.-&gt; HN(*Homininae*)\n            subgraph cluster3 [\"*Homo sapiens*, *Gorilla gorilla*\"]\n                HN\n            end\n        end\n    end\n    HN -.-&gt; H(*Homo sapiens*)\n    HN -.-&gt; GG(*Gorilla gorilla*)\n    E --&gt; G(*Glires*)\n    G --&gt; L(*Lagomorpha*)\n    O --&gt; F(*Fungi*) -...-&gt; S(*Saccharomyces*)</code></pre> <p>If we consider Lagomorpha, Homo sapiens, and Gorilla gorilla (ignoring Saccharomyces for now), the most specific taxon that is shared by more than half of these three taxa is Homininae, which is common to two of them. However, if we want to determine the most specific taxon that is common to more than two-thirds of the lineages, we can change the value of <code>fraction</code> to <code>0.67</code>. This will return Euarchontoglires, which, in this particular case, is also the LCA of the three lineages.</p> <pre><code>&gt;&gt;&gt; print(taxopy.find_majority_vote([lagomorpha, human, gorilla], taxdb).name)\nHomininae\n&gt;&gt;&gt; print(\n...     taxopy.find_majority_vote(\n...         [lagomorpha, human, gorilla], taxdb, fraction=0.67\n...     ).name\n... )\nEuarchontoglires\n</code></pre> <p>The level of agreement among the lineages used to find the common taxon is stored in the <code>agreement</code> attribute. This is computed as the ratio of the number of lineages in which the shared taxon is present to the total number of lineages used.</p> <pre><code>&gt;&gt;&gt; print(\n...     taxopy.find_majority_vote(\n...         [lagomorpha, human, gorilla], taxdb\n...     ).agreement\n... )\n0.6666666666666666\n&gt;&gt;&gt; print(\n...     taxopy.find_majority_vote(\n...         [lagomorpha, human, gorilla], taxdb, fraction=0.67\n...     ).agreement\n... )\n1.0\n</code></pre>"},{"location":"guide/#the-weights-parameter","title":"The <code>weights</code> parameter","text":"<p><code>find_majority_vote</code> also allows you to assign different weights to taxa when determining the shared taxon using the <code>weights</code> parameter. For example, the most specific taxon common to more than half of the four taxa in the figure above is Euarchontoglires (shared by three out of the four). However, if we set the weight of Saccharomyces to <code>3</code> and the weights of the remaining lineages to <code>1</code> each, the function will return Opisthokonta, effectively balancing the total weight of Saccharomyces with the three Euarchontoglires taxa.</p> <pre><code>&gt;&gt;&gt; print(\n...     taxopy.find_majority_vote(\n...         [saccharomyces, human, gorilla, lagomorpha], taxdb\n...     ).name\n... )\nEuarchontoglires\n&gt;&gt;&gt; print(\n...     taxopy.find_majority_vote(\n...         [saccharomyces, human, gorilla, lagomorpha],\n...         taxdb,\n...         weights=[3, 1, 1, 1],\n...     ).name\n... )\nOpisthokonta\n</code></pre> <p>This functionality is useful in various scenarios. For example, if you have a set of taxa with different numbers of individuals in a community, you can use the number of individuals of each taxon as weights to determine the most specific taxon common to more than half of the individuals. Another popular application is the taxonomic assignment of metagenomic sequences<sup>1</sup><sup>,</sup><sup>2</sup>. In this case, each gene within a sequence is assigned to a taxon through alignment to reference genes, and the confidence of these assignments (quantified as alignment scores) is used as weights to determine a representative taxon for the entire sequence.</p>"},{"location":"guide/#retrieving-taxids-from-taxa-names","title":"Retrieving TaxIds from taxa names","text":"<p>In many cases, you might have the names of taxa of interest but not their corresponding TaxIds. <code>taxopy</code> provides the <code>taxid_from_name</code> function, which allows you to programmatically retrieve TaxIds based on taxa names. You can input a single scientific name or a list of names, and the function will return a list of TaxIds or a list of lists of TaxIds, respectively.</p> <pre><code>&gt;&gt;&gt; print(taxopy.taxid_from_name(\"Homininae\", taxdb))\n[207598]\n&gt;&gt;&gt; print(taxopy.taxid_from_name([\"Homininae\", \"Homo sapiens\"], taxdb))\n[[207598], [9606]]\n</code></pre> <p>Some taxa may share the same name, which are known as homonyms. In such cases, the returned list will include multiple TaxIds.</p> <pre><code>&gt;&gt;&gt; print(taxopy.taxid_from_name(\"Aotus\", taxdb))\n[9504, 114498]\n&gt;&gt;&gt; for ti in taxopy.taxid_from_name(\n...     [\"Homininae\", \"Homo sapiens\", \"Aotus\"], taxdb\n... ):\n...     print(f\"{ti}:\")\n...     for t in ti:\n...         taxon = taxopy.Taxon(t, taxdb)\n...         parent_taxon = taxon.parent(taxdb)\n...         print(f\"{taxon.name} (TaxId: {t}, parent: {parent_taxon.name})\")\n[207598]:\nHomininae (TaxId: 207598, parent: Hominidae)\n[9606]:\nHomo sapiens (TaxId: 9606, parent: Homo)\n[9504, 114498]:\nAotus (TaxId: 9504, parent: Aotidae)\nAotus (TaxId: 114498, parent: Mirbelieae)\n</code></pre>"},{"location":"guide/#retrieval-of-taxa-with-nearly-matching-names-though-fuzzy-search","title":"Retrieval of taxa with nearly matching names though fuzzy search","text":"<p>When querying a <code>TaxDb</code> using a taxon name, you can enable fuzzy search by setting the <code>fuzzy</code> parameter of <code>taxid_from_name</code> to <code>True</code>. This allows the function to find taxa with names similar, but not identical, to the query string(s).</p> <p>For a practical use case of this feature, consider the GTDB taxonomy. In GTDB some taxa have suffixes appended to their names because they are either not monophyletic in the GTDB reference tree or have unstable placements between different releases. By using fuzzy searches, you can find all the TaxIds representing a given taxon, such as Myxococcota, without needing to know in advance if any suffixes are appended to the name.</p> <pre><code>&gt;&gt;&gt; url = \"https://github.com/shenwei356/gtdb-taxdump/releases/download/v0.5.0/gtdb-taxdump-R220.tar.gz\"\n&gt;&gt;&gt; gtdb_taxdb = taxopy.TaxDb(taxdump_url=url)# (1)!\n&gt;&gt;&gt; for t in taxopy.taxid_from_name(\"Myxococcota\", gtdb_taxdb, fuzzy=True):\n...     print(taxopy.Taxon(t, gtdb_taxdb).name)\nMyxococcota_A\nMyxococcota\n</code></pre> <ol> <li>This custom GTDB taxdump was generated by Wei Shen using the TaxonKit toolkit and is available for download from GitHub.</li> </ol> <p>You can adjust the minimum similarity threshold between the query string(s) and the matches in the database using the <code>score_cutoff</code> parameter, which determines how closely a name must match a query string to be considered a valid result. The default value is <code>0.9</code>, but you can lower this threshold to find matches that are less similar to the queries.</p> <pre><code>&gt;&gt;&gt; for t in taxopy.taxid_from_name(\n...     \"Myxococcota\", gtdb_taxdb, fuzzy=True, score_cutoff=0.7\n... ):\n...     print(taxopy.Taxon(t, gtdb_taxdb).name)\nMyxococcales\nMyxococcota_A\nMyxococcus\nMyxococcia\nMyxococcota\nMyxococcaceae\n</code></pre> <ol> <li> <p>Von Meijenfeldt, F. A. B., Arkhipova, K., Cambuy, D. D., Coutinho, F. H. &amp; Dutilh, B. E. \"Robust taxonomic classification of uncharted microbial sequences and bins with CAT and BAT\". Genome Biology 20, 217 (2019).\u00a0\u21a9</p> </li> <li> <p>Mirdita, M., Steinegger, M., Breitwieser, F., S\u00f6ding, J. &amp; Levy Karin, E. \"Fast and sensitive taxonomic assignment to metagenomic contigs\". Bioinformatics 37, 3029\u20133031 (2021).\u00a0\u21a9</p> </li> </ol>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#taxopy.TaxDb","title":"taxopy.TaxDb","text":"<p>Create an object of the TaxDb class.</p> <p>Parameters:</p> Name Type Description Default <code>taxdb_dir</code> <code>str</code> <p>A directory to download NCBI's taxonomy database files to. If the directory does not exist it will be created.</p> <code>None</code> <code>nodes_dmp</code> <code>str</code> <p>The path for a pre-downloaded <code>nodes.dmp</code> file. If both <code>nodes.dmp</code> and <code>names.dmp</code> are supplied NCBI's taxonomy database won't be downloaded.</p> <code>None</code> <code>names_dmp</code> <code>str</code> <p>The path for a pre-downloaded <code>names.dmp</code> file. If both <code>names.dmp</code> and <code>nodes.dmp</code> are supplied NCBI's taxonomy database won't be downloaded.</p> <code>None</code> <code>merged_dmp</code> <code>str</code> <p>The path for a pre-downloaded <code>merged.dmp</code> file.</p> <code>None</code> <code>taxdump_url</code> <code>str</code> <p>The URL of the taxdump file (in .tar.gz) to be downloaded. By default, the latest version of NCBI's taxdump will be fetched.</p> <code>None</code> <code>keep_files</code> <code>bool</code> <p>Keep the <code>nodes.dmp</code> and <code>names.dmp</code> files after the TaxDb object is created. If <code>taxdb_dir</code> was supplied the whole directory will be deleted. By default the files are deleted, unless <code>nodes_dmp</code>, <code>names_dmp</code>, or <code>taxdb_dir</code> were manually supplied.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>taxid2name</code> <code>dict</code> <p>A dictionary where the keys are taxonomic identifiers and the values are their corresponding scientific names.</p> <code>taxid2all_names</code> <code>dict</code> <p>A two-level dictionary where the keys are the taxonomic identifiers, yielding a dictionary mapping the kinds of names from the NCBI taxonomy (e.g. \"scientific name\", \"common name\") to the corresponding names.</p> <code>taxid2parent</code> <code>dict</code> <p>A dictionary where the keys are taxonomic identifiers and the values are the taxonomic identifiers of their corresponding parent taxon.</p> <code>taxid2rank</code> <code>dict</code> <p>A dictionary where the keys are taxonomic identifiers and the values are their corresponding ranks.</p> <code>oldtaxid2newtaxid</code> <code>dict or None</code> <p>A dictionary where the keys are legacy taxonomic identifiers and the values are their corresponding new identifiers. If pre-downloaded <code>nodes.dmp</code> and <code>names.dmp</code> files were provided but the <code>merged.dmp</code> file was not supplied, this attribute will be <code>None</code>.</p> <p>Raises:</p> Type Description <code>DownloadError</code> <p>If the download of the taxonomy database fails.</p> <code>ExtractionError</code> <p>If the decompression of the taxonomy database fails.</p> Source code in <code>taxopy/core.py</code> <pre><code>class TaxDb:\n    \"\"\"\n    Create an object of the TaxDb class.\n\n    Parameters\n    ----------\n    taxdb_dir : str, optional\n        A directory to download NCBI's taxonomy database files to. If the\n        directory does not exist it will be created.\n    nodes_dmp : str, optional\n        The path for a pre-downloaded `nodes.dmp` file. If both `nodes.dmp` and\n        `names.dmp` are supplied NCBI's taxonomy database won't be downloaded.\n    names_dmp : str, optional\n        The path for a pre-downloaded `names.dmp` file. If both `names.dmp` and\n        `nodes.dmp` are supplied NCBI's taxonomy database won't be downloaded.\n    merged_dmp : str, optional\n        The path for a pre-downloaded `merged.dmp` file.\n    taxdump_url : str, optional\n        The URL of the taxdump file (in .tar.gz) to be downloaded. By default,\n        the latest version of NCBI's taxdump will be fetched.\n    keep_files : bool, default False\n        Keep the `nodes.dmp` and `names.dmp` files after the TaxDb object is\n        created. If `taxdb_dir` was supplied the whole directory will be deleted.\n        By default the files are deleted, unless `nodes_dmp`, `names_dmp`, or\n        `taxdb_dir` were manually supplied.\n\n    Attributes\n    ----------\n    taxid2name : dict\n        A dictionary where the keys are taxonomic identifiers and the values are\n        their corresponding scientific names.\n    taxid2all_names : dict\n        A two-level dictionary where the keys are the taxonomic identifiers,\n        yielding a dictionary mapping the kinds of names from the NCBI\n        taxonomy (e.g. \"scientific name\", \"common name\") to the corresponding\n        names.\n    taxid2parent: dict\n        A dictionary where the keys are taxonomic identifiers and the values are\n        the taxonomic identifiers of their corresponding parent taxon.\n    taxid2rank: dict\n        A dictionary where the keys are taxonomic identifiers and the values are\n        their corresponding ranks.\n    oldtaxid2newtaxid: dict or None\n        A dictionary where the keys are legacy taxonomic identifiers and the\n        values are their corresponding new identifiers. If pre-downloaded\n        `nodes.dmp` and `names.dmp` files were provided but the `merged.dmp`\n        file was not supplied, this attribute will be `None`.\n\n    Raises\n    ------\n    DownloadError\n        If the download of the taxonomy database fails.\n    ExtractionError\n        If the decompression of the taxonomy database fails.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        taxdb_dir: Optional[str] = None,\n        taxdump_url: Optional[str] = None,\n        nodes_dmp: Optional[str] = None,\n        names_dmp: Optional[str] = None,\n        merged_dmp: Optional[str] = None,\n        keep_files: bool = False,\n    ):\n        if not taxdb_dir:\n            self._taxdb_dir = os.getcwd()\n        elif not os.path.isdir(taxdb_dir):\n            os.makedirs(taxdb_dir)\n            self._taxdb_dir = taxdb_dir\n        else:\n            self._taxdb_dir = taxdb_dir\n        # If `nodes_dmp` and `names_dmp` were not provided:\n        if not nodes_dmp or not names_dmp:\n            nodes_dmp_path = os.path.join(self._taxdb_dir, \"nodes.dmp\")\n            names_dmp_path = os.path.join(self._taxdb_dir, \"names.dmp\")\n            merged_dmp_path = os.path.join(self._taxdb_dir, \"merged.dmp\")\n            # If the `nodes.dmp` and `names.dmp` files are not in the `taxdb_dir` directory,\n            # download the taxonomy from NCBI:\n            if not os.path.isfile(nodes_dmp_path) or not os.path.isfile(names_dmp_path):\n                (\n                    self._nodes_dmp,\n                    self._names_dmp,\n                    self._merged_dmp,\n                ) = self._download_taxonomy(taxdump_url)\n            else:\n                self._nodes_dmp, self._names_dmp = nodes_dmp_path, names_dmp_path\n                # If `merged.dmp` is not in the `taxdb_dir` directory, set the `_merged_dmp`\n                # attribute to `None`:\n                self._merged_dmp = (\n                    merged_dmp_path if os.path.isfile(merged_dmp_path) else None\n                )\n        else:\n            self._nodes_dmp, self._names_dmp = nodes_dmp, names_dmp\n            # If `merged_dmp` was not provided, set the `_merged_dmp` attribute to `None`:\n            self._merged_dmp = merged_dmp or None\n        # If a `merged.dmp` file was provided or downloaded, create the oldtaxid2newtaxid\n        # dictionary:\n        self._oldtaxid2newtaxid = self._import_merged() if self._merged_dmp else None\n        # Create the taxid2parent, taxid2rank, and taxid2name dictionaries:\n        self._taxid2parent, self._taxid2rank = self._import_nodes()\n        self._taxid2name, self._taxid2all_names = self._import_names()\n        # Delete temporary files if `keep_files` is set to `False`, unless\n        # `nodes_dmp`, `names_dmp`, or `taxdb_dir` were manually supplied:\n        # Determine whether to delete files based on multiple conditions\n        if all([\n            # User hasn't explicitly requested to keep files\n            not keep_files,\n            # Files weren't manually provided by user\n            (not nodes_dmp or not names_dmp or not taxdb_dir),\n        ]):\n            self._delete_files()\n\n    @property\n    def taxid2name(self) -&gt; Dict[int, str]:\n        return self._taxid2name\n\n    @property\n    def taxid2all_names(self) -&gt; Dict[int, dict[str, List[str]]]:\n        return self._taxid2all_names\n\n    @property\n    def taxid2parent(self) -&gt; Dict[int, int]:\n        return self._taxid2parent\n\n    @property\n    def taxid2rank(self) -&gt; Dict[int, str]:\n        return self._taxid2rank\n\n    @property\n    def oldtaxid2newtaxid(self) -&gt; Optional[Dict[int, int]]:\n        return self._oldtaxid2newtaxid\n\n    def _download_taxonomy(self, url: Optional[str] = None):\n        if not url:\n            url = \"ftp://ftp.ncbi.nlm.nih.gov/pub/taxonomy/taxdump.tar.gz\"\n        tmp_taxonomy_file = os.path.join(self._taxdb_dir, \"taxdump.tar.gz\")\n        try:\n            urllib.request.urlretrieve(url, tmp_taxonomy_file)\n        except:\n            raise DownloadError(\n                \"Download of taxonomy files failed. The server may be offline.\"\n            )\n        try:\n            with tarfile.open(tmp_taxonomy_file) as tf:\n                for member in tf.getmembers():\n                    if not member.isfile():\n                        continue\n                    filename = os.path.basename(member.name)\n                    if filename not in (\"nodes.dmp\", \"names.dmp\", \"merged.dmp\"):\n                        continue\n                    m = tf.extractfile(member)\n                    with open(os.path.join(self._taxdb_dir, filename), \"wb\") as fo:\n                        while True:\n                            chunk = m.read(1024)\n                            if not chunk:\n                                break\n                            fo.write(chunk)\n        except:\n            raise ExtractionError(\n                \"Something went wrong while extracting the taxonomy files.\"\n            )\n        os.remove(tmp_taxonomy_file)\n        return (\n            os.path.join(self._taxdb_dir, \"nodes.dmp\"),\n            os.path.join(self._taxdb_dir, \"names.dmp\"),\n            os.path.join(self._taxdb_dir, \"merged.dmp\"),\n        )\n\n    def _import_merged(self):\n        oldtaxid2newtaxid = {}\n        with open(self._merged_dmp, \"r\") as f:\n            for line in f:\n                line = line.split(\"\\t\")\n                taxid = int(line[0])\n                merged = int(line[2])\n                oldtaxid2newtaxid[taxid] = merged\n        return oldtaxid2newtaxid\n\n    def _import_nodes(self):\n        taxid2parent = {}\n        taxid2rank = {}\n        with open(self._nodes_dmp, \"r\") as f:\n            for line in f:\n                line = line.split(\"\\t\")\n                taxid = int(line[0])\n                parent = int(line[2])\n                rank = line[4].strip()\n                taxid2parent[taxid] = parent\n                taxid2rank[taxid] = rank\n        if self._merged_dmp:\n            for oldtaxid, newtaxid in self._oldtaxid2newtaxid.items():\n                taxid2rank[oldtaxid] = taxid2rank[newtaxid]\n                taxid2parent[oldtaxid] = taxid2parent[newtaxid]\n        return taxid2parent, taxid2rank\n\n    def _import_names(self) -&gt; Tuple[Dict[int, str], Dict[int, dict[str, List[str]]]]:\n        taxid2name: Dict[int, str] = {}\n        taxid2all_names: Dict[int, dict[str, List[str]]] = {}\n\n        with open(self._names_dmp, \"r\") as f:\n            for line in f:\n                fields = line.strip(\"\\n\").split(\"\\t\")\n                kind = fields[6]\n                taxid = int(fields[0])\n                name = fields[2].strip()\n\n                if kind == \"scientific name\":\n                    taxid2name[taxid] = name\n\n                if taxid not in taxid2all_names:\n                    taxid2all_names[taxid] = {}\n\n                if kind not in taxid2all_names[taxid]:\n                    taxid2all_names[taxid][kind] = []\n\n                taxid2all_names[taxid][kind].append(name)\n\n        if self._merged_dmp:\n            for oldtaxid, newtaxid in self._oldtaxid2newtaxid.items():\n                taxid2name[oldtaxid] = taxid2name[newtaxid]\n                taxid2all_names[oldtaxid] = taxid2all_names[newtaxid]\n\n        return taxid2name, taxid2all_names\n\n    def _delete_files(self):\n        os.remove(self._nodes_dmp)\n        os.remove(self._names_dmp)\n        if self._merged_dmp:\n            os.remove(self._merged_dmp)\n        if not os.listdir(self._taxdb_dir) and self._taxdb_dir != os.getcwd():\n            os.rmdir(self._taxdb_dir)\n</code></pre>"},{"location":"reference/#taxopy.Taxon","title":"taxopy.Taxon","text":"<p>Create an object of the Taxon class.</p> <p>Parameters:</p> Name Type Description Default <code>taxid</code> <code>int</code> <p>A NCBI taxonomic identifier.</p> required <code>taxdb</code> <code>TaxDb</code> <p>A TaxDb object.</p> required <p>Attributes:</p> Name Type Description <code>taxid</code> <code>int</code> <p>The NCBI taxonomic identifier the object represents (e.g., 9606).</p> <code>name</code> <code>str</code> <p>The name of the taxon (e.g., 'Homo sapiens').</p> <code>all_names</code> <code>dict</code> <p>All names of the taxon as a dictionary, mapping kind to the list of names (e.g., <code>all_names['authority'] = ['Homo sapiens Linnaeus, 1758']</code>, <code>all_names['genbank common name'] = ['human']</code>. In many cases, only one name is provided, but e.g. for <code>common name</code> multiple names may be available.</p> <code>rank</code> <code>str</code> <p>The rank of the taxon (e.g., 'species').</p> <code>legacy_taxid</code> <code>bool</code> <p>A boolean that represents whether the NCBI taxonomic identifier was merged to another identifier (<code>True</code>) or not (<code>False</code>). If pre-downloaded <code>nodes.dmp</code> and <code>names.dmp</code> files were provided to build <code>taxdb</code> but the <code>merged.dmp</code> file was not supplied, this attribute will be <code>None</code>.</p> <code>taxid_lineage</code> <code>list</code> <p>An ordered list containing the taxonomic identifiers of the whole lineage of the taxon, from the most specific to the most general.</p> <code>name_lineage</code> <code>list</code> <p>An ordered list containing the names of the whole lineage of the taxon, from the most specific to the most general.</p> <code>rank_lineage</code> <code>list</code> <p>An ordered list containing the rank names of the whole lineage of the taxon, from the most specific to the most general.</p> <code>ranked_name_lineage</code> <code>list</code> <p>An ordered list of tuples, where each tuple represents a rank in the lineage, with the first element denoting the rank name and the second indicating the taxon's name.</p> <code>ranked_taxid_lineage</code> <code>list</code> <p>An ordered list of tuples, where each tuple represents a rank in the lineage, with the first element denoting the rank name and the second indicating the taxon's taxonomic identifier.</p> <code>rank_taxid_dictionary</code> <code>dict</code> <p>A dictionary where the keys are named ranks and the values are the taxids of the taxa that correspond to each of the named ranks in the lineage.</p> <code>rank_name_dictionary</code> <code>dict</code> <p>A dictionary where the keys are named ranks and the values are the names of the taxa that correspond to each of the named ranks in the lineage.</p> <p>Methods:</p> Name Description <code>parent</code> <p>Returns a Taxon object of the parent node.</p> <p>Raises:</p> Type Description <code>TaxidError</code> <p>If the input integer is not a valid NCBI taxonomic identifier.</p> Source code in <code>taxopy/core.py</code> <pre><code>class Taxon:\n    \"\"\"\n    Create an object of the Taxon class.\n\n    Parameters\n    ----------\n    taxid : int\n        A NCBI taxonomic identifier.\n    taxdb : TaxDb\n        A TaxDb object.\n\n    Attributes\n    ----------\n    taxid : int\n        The NCBI taxonomic identifier the object represents (e.g., 9606).\n    name: str\n        The name of the taxon (e.g., 'Homo sapiens').\n    all_names: dict\n        All names of the taxon as a dictionary, mapping kind to the list of names\n        (e.g., `all_names['authority'] = ['Homo sapiens Linnaeus, 1758']`,\n        `all_names['genbank common name'] = ['human']`. In many cases, only one\n        name is provided, but e.g. for `common name` multiple names may be available.\n    rank: str\n        The rank of the taxon (e.g., 'species').\n    legacy_taxid: bool\n        A boolean that represents whether the NCBI taxonomic identifier was\n        merged to another identifier (`True`) or not (`False`). If pre-downloaded\n        `nodes.dmp` and `names.dmp` files were provided to build `taxdb` but the\n        `merged.dmp` file was not supplied, this attribute will be `None`.\n    taxid_lineage: list\n        An ordered list containing the taxonomic identifiers of the whole lineage\n        of the taxon, from the most specific to the most general.\n    name_lineage: list\n        An ordered list containing the names of the whole lineage of the taxon,\n        from the most specific to the most general.\n    rank_lineage: list\n        An ordered list containing the rank names of the whole lineage of the\n        taxon, from the most specific to the most general.\n    ranked_name_lineage : list\n        An ordered list of tuples, where each tuple represents a rank in the\n        lineage, with the first element denoting the rank name and the second\n        indicating the taxon's name.\n    ranked_taxid_lineage : list\n        An ordered list of tuples, where each tuple represents a rank in the\n        lineage, with the first element denoting the rank name and the second\n        indicating the taxon's taxonomic identifier.\n    rank_taxid_dictionary: dict\n        A dictionary where the keys are named ranks and the values are the taxids\n        of the taxa that correspond to each of the named ranks in the lineage.\n    rank_name_dictionary: dict\n        A dictionary where the keys are named ranks and the values are the names\n        of the taxa that correspond to each of the named ranks in the lineage.\n\n    Methods\n    -------\n    parent(taxdb)\n        Returns a Taxon object of the parent node.\n\n    Raises\n    ------\n    TaxidError\n        If the input integer is not a valid NCBI taxonomic identifier.\n    \"\"\"\n\n    _legacy_taxid: Optional[bool]\n\n    def __init__(self, taxid: int, taxdb: TaxDb):\n        self._taxid = taxid\n        if self.taxid not in taxdb.taxid2name:\n            raise TaxidError(\n                \"The input integer is not a valid NCBI taxonomic identifier.\"\n            )\n        self._name = taxdb.taxid2name[self.taxid]\n        self._all_names = taxdb.taxid2all_names[self.taxid]\n        self._rank = taxdb.taxid2rank[self.taxid]\n        if taxdb.oldtaxid2newtaxid:\n            self._legacy_taxid = self.taxid in taxdb.oldtaxid2newtaxid\n        else:\n            self._legacy_taxid = None\n        self._taxid_lineage = self._find_lineage(taxdb.taxid2parent)\n        self._name_lineage = self._convert_to_names(taxdb.taxid2name)\n        self._rank_lineage = [taxdb._taxid2rank[taxid] for taxid in self.taxid_lineage]\n        (\n            self._rank_taxid_dictionary,\n            self._rank_name_dictionary,\n        ) = self._convert_to_rank_dictionary(taxdb.taxid2rank, taxdb.taxid2name)\n\n    @property\n    def taxid(self) -&gt; int:\n        return self._taxid\n\n    @property\n    def name(self) -&gt; str:\n        return self._name\n\n    @property\n    def all_names(self) -&gt; Dict[str, List[str]]:\n        return self._all_names\n\n    @property\n    def rank(self) -&gt; str:\n        return self._rank\n\n    @property\n    def legacy_taxid(self) -&gt; Optional[bool]:\n        return self._legacy_taxid\n\n    @property\n    def taxid_lineage(self) -&gt; List[int]:\n        return self._taxid_lineage\n\n    @property\n    def name_lineage(self) -&gt; List[str]:\n        return self._name_lineage\n\n    @property\n    def rank_lineage(self) -&gt; List[str]:\n        return self._rank_lineage\n\n    @property\n    def ranked_taxid_lineage(self) -&gt; List[Tuple[str, int]]:\n        return list(zip(self.rank_lineage, self.taxid_lineage))\n\n    @property\n    def ranked_name_lineage(self) -&gt; List[Tuple[str, str]]:\n        return list(zip(self.rank_lineage, self.name_lineage))\n\n    @property\n    def rank_taxid_dictionary(self) -&gt; Dict[str, int]:\n        return self._rank_taxid_dictionary\n\n    @property\n    def rank_name_dictionary(self) -&gt; Dict[str, str]:\n        return self._rank_name_dictionary\n\n    def parent(self, taxdb) -&gt; Taxon:\n        \"\"\"\n        Returns the parent node of the taxon.\n\n        Returns\n        -------\n        Taxon\n            The Taxon object of the parent node.\n        \"\"\"\n        parent_taxid = taxdb.taxid2parent[self.taxid]\n        return Taxon(parent_taxid, taxdb)\n\n    def _find_lineage(self, taxid2parent):\n        current_taxid = self.taxid\n        lineage = [current_taxid]\n        while taxid2parent[current_taxid] != current_taxid:\n            current_taxid = taxid2parent[current_taxid]\n            lineage.append(current_taxid)\n        return lineage\n\n    def _convert_to_names(self, taxid2name):\n        return [taxid2name[taxid] for taxid in self.taxid_lineage]\n\n    def _convert_to_rank_dictionary(self, taxid2rank, taxid2name):\n        rank_taxid_dictionary = OrderedDict()\n        rank_name_dictionary = OrderedDict()\n        for taxid in self.taxid_lineage:\n            rank = taxid2rank[taxid]\n            if rank != \"no rank\":\n                rank_taxid_dictionary[rank] = taxid\n                rank_name_dictionary[rank] = taxid2name[taxid]\n        return rank_taxid_dictionary, rank_name_dictionary\n\n    def __str__(self) -&gt; str:\n        lineage = [\n            f\"{rank[0]}__{name}\" for rank, name in self.rank_name_dictionary.items()\n        ]\n        return \";\".join(reversed(lineage))\n\n    def __repr__(self) -&gt; str:\n        return str(self)\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, Taxon):\n            return NotImplemented\n        return self.taxid_lineage == other.taxid_lineage\n\n    def __hash__(self) -&gt; int:\n        return hash(self.taxid)\n</code></pre>"},{"location":"reference/#taxopy.Taxon.parent","title":"parent","text":"<pre><code>parent(taxdb) -&gt; Taxon\n</code></pre> <p>Returns the parent node of the taxon.</p> <p>Returns:</p> Type Description <code>Taxon</code> <p>The Taxon object of the parent node.</p> Source code in <code>taxopy/core.py</code> <pre><code>def parent(self, taxdb) -&gt; Taxon:\n    \"\"\"\n    Returns the parent node of the taxon.\n\n    Returns\n    -------\n    Taxon\n        The Taxon object of the parent node.\n    \"\"\"\n    parent_taxid = taxdb.taxid2parent[self.taxid]\n    return Taxon(parent_taxid, taxdb)\n</code></pre>"},{"location":"reference/#taxopy.find_lca","title":"taxopy.find_lca","text":"<pre><code>find_lca(taxon_list: list[Taxon], taxdb: TaxDb) -&gt; Taxon\n</code></pre> <p>Takes a list of multiple Taxon objects and returns their lowest common ancestor (LCA).</p> <p>Parameters:</p> Name Type Description Default <code>taxon_list</code> <code>list of Taxon</code> <p>A list containing at least two Taxon objects.</p> required <code>taxdb</code> <code>TaxDb</code> <p>A TaxDb object.</p> required <p>Returns:</p> Type Description <code>_AggregatedTaxon</code> <p>The _AggregatedTaxon object of the lowest common ancestor (LCA) of the inputs.</p> <p>Raises:</p> Type Description <code>LCAError</code> <p>When the input list contains fewer than two Taxon objects or when no taxa are common across the provided lineages.</p> Source code in <code>taxopy/utilities.py</code> <pre><code>def find_lca(taxon_list: List[Taxon], taxdb: TaxDb) -&gt; Taxon:\n    \"\"\"\n    Takes a list of multiple Taxon objects and returns their lowest common\n    ancestor (LCA).\n\n    Parameters\n    ----------\n    taxon_list : list of Taxon\n        A list containing at least two Taxon objects.\n    taxdb : TaxDb\n        A TaxDb object.\n\n    Returns\n    -------\n    _AggregatedTaxon\n        The _AggregatedTaxon object of the lowest common ancestor (LCA) of the\n        inputs.\n\n    Raises\n    ------\n    LCAError\n        When the input list contains fewer than two Taxon objects or when no\n        taxa are common across the provided lineages.\n    \"\"\"\n    if len(taxon_list) &lt; 2:\n        raise LCAError(\"The input list must contain at least two Taxon objects.\")\n    lineage_list = [taxon.taxid_lineage for taxon in taxon_list]\n    overlap = set.intersection(*map(set, lineage_list))\n    for taxid in lineage_list[0]:\n        if taxid in overlap:\n            aggregated_taxa = [taxon.taxid for taxon in taxon_list]\n            return _AggregatedTaxon(taxid, taxdb, 1.0, aggregated_taxa)\n    raise LCAError(\"No taxon is shared by the input lineages.\")\n</code></pre>"},{"location":"reference/#taxopy.find_majority_vote","title":"taxopy.find_majority_vote","text":"<pre><code>find_majority_vote(taxon_list: list[Taxon], taxdb: TaxDb, fraction: float = 0.5, weights: list[float] | None = None) -&gt; Taxon\n</code></pre> <p>Takes a list of multiple Taxon objects and returns the most specific taxon that is shared by more than the chosen fraction of the input lineages.</p> <p>Parameters:</p> Name Type Description Default <code>taxon_list</code> <code>list of Taxon</code> <p>A list containing at least two Taxon objects.</p> required <code>taxdb</code> <code>TaxDb</code> <p>A TaxDb object.</p> required <code>fraction</code> <code>float</code> <p>The returned taxon will be shared by more than <code>fraction</code> of the input taxa lineages. This value must be greater than 0.0 and less than 1.0.</p> <code>0.5</code> <code>weights</code> <code>list[float] | None</code> <p>A list of weights associated with the taxa lineages in <code>taxon_list</code>. These values are used to weight the votes of their associated lineages.</p> <code>None</code> <p>Returns:</p> Type Description <code>_AggregatedTaxon</code> <p>The _AggregatedTaxon object of the most specific taxon that is shared by more than the chosen fraction of the input lineages.</p> <p>Raises:</p> Type Description <code>MajorityVoteError</code> <p>If any of the following conditions occur: the input taxon list contains fewer than two Taxon objects; the fraction parameter is less than or equal to 0.0 or greater than or equal to 1.0; or there are no taxa common to the input lineages.</p> Source code in <code>taxopy/utilities.py</code> <pre><code>def find_majority_vote(\n    taxon_list: List[Taxon],\n    taxdb: TaxDb,\n    fraction: float = 0.5,\n    weights: Optional[List[float]] = None,\n) -&gt; Taxon:\n    \"\"\"\n    Takes a list of multiple Taxon objects and returns the most specific taxon\n    that is shared by more than the chosen fraction of the input lineages.\n\n    Parameters\n    ----------\n    taxon_list : list of Taxon\n        A list containing at least two Taxon objects.\n    taxdb : TaxDb\n        A TaxDb object.\n    fraction: float, default 0.5\n        The returned taxon will be shared by more than `fraction` of the input\n        taxa lineages. This value must be greater than 0.0 and less than 1.0.\n    weights: list of float, optional\n        A list of weights associated with the taxa lineages in `taxon_list`.\n        These values are used to weight the votes of their associated lineages.\n\n    Returns\n    -------\n    _AggregatedTaxon\n        The _AggregatedTaxon object of the most specific taxon that is shared by\n        more than the chosen fraction of the input lineages.\n\n    Raises\n    ------\n    MajorityVoteError\n        If any of the following conditions occur: the input taxon list contains\n        fewer than two Taxon objects; the fraction parameter is less than or\n        equal to 0.0 or greater than or equal to 1.0; or there are no taxa\n        common to the input lineages.\n    \"\"\"\n    if fraction &lt;= 0.0 or fraction &gt;= 1:\n        raise MajorityVoteError(\n            \"The `fraction` parameter must be greater than 0.0 and less than 1.\"\n        )\n    if len(taxon_list) &lt; 2:\n        raise MajorityVoteError(\n            \"The input taxon list must contain at least two Taxon objects.\"\n        )\n    if weights and len(taxon_list) != len(weights):\n        raise MajorityVoteError(\n            \"The input taxon and weights lists must have the same length.\"\n        )\n    if weights:\n        majority_vote = _weighted_majority_vote(taxon_list, taxdb, fraction, weights)\n    else:\n        majority_vote = _unweighted_majority_vote(taxon_list, taxdb, fraction)\n    if majority_vote:\n        return majority_vote\n    else:\n        raise MajorityVoteError(\"No taxon is shared by the input lineages.\")\n</code></pre>"},{"location":"reference/#taxopy.taxid_from_name","title":"taxopy.taxid_from_name","text":"<pre><code>taxid_from_name(names: str | list[str], taxdb: TaxDb, fuzzy: bool = False, score_cutoff: float = 0.9) -&gt; list[int] | list[list[int]]\n</code></pre> <p>Takes one (or more) taxon name and returns a list (or list of lists) containing the taxonomic identifiers associated with it (or them).</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>str or list of str</code> <p>The name of the taxon whose taxonomic identifier will be returned. A list of names can also be provided.</p> required <code>taxdb</code> <code>TaxDb</code> <p>A TaxDb object.</p> required <code>fuzzy</code> <code>bool</code> <p>If True, the input name will be matched to the taxa names in the database using fuzzy string matching.</p> <code>False</code> <code>score_cutoff</code> <code>float</code> <p>The minimum score required for a match to be considered valid when fuzzy string matching is used. This value must be between 0.0 and 1.0.</p> <code>0.9</code> <p>Returns:</p> Type Description <code>list or list of list</code> <p>A list of all the taxonomic identifiers associated with the input taxon name. If a list of names is provided, a list of lists is returned.</p> Source code in <code>taxopy/utilities.py</code> <pre><code>def taxid_from_name(\n    names: Union[str, List[str]],\n    taxdb: TaxDb,\n    fuzzy: bool = False,\n    score_cutoff: float = 0.9,\n) -&gt; Union[List[int], List[List[int]]]:\n    \"\"\"\n    Takes one (or more) taxon name and returns a list (or list of lists)\n    containing the taxonomic identifiers associated with it (or them).\n\n    Parameters\n    ----------\n    names : str or list of str\n        The name of the taxon whose taxonomic identifier will be returned. A\n        list of names can also be provided.\n    taxdb : TaxDb\n        A TaxDb object.\n    fuzzy : bool, default False\n        If True, the input name will be matched to the taxa names in the\n        database using fuzzy string matching.\n    score_cutoff : float, default 0.9\n        The minimum score required for a match to be considered valid when\n        fuzzy string matching is used. This value must be between 0.0 and 1.0.\n\n    Returns\n    -------\n    list or list of list\n        A list of all the taxonomic identifiers associated with the input taxon\n        name. If a list of names is provided, a list of lists is returned.\n    \"\"\"\n    score_cutoff = score_cutoff * 100\n    if isinstance(names, list):\n        taxid_list = _get_taxid_from_multiple_names(names, taxdb, fuzzy, score_cutoff)\n        if not all(len(taxids) for taxids in taxid_list):\n            warnings.warn(\n                \"At least one of the input names was not found in the taxonomy database.\",\n                Warning,\n            )\n    else:\n        taxid_list = _get_taxid_from_single_name(names, taxdb, fuzzy, score_cutoff)\n        if not len(taxid_list):\n            warnings.warn(\n                \"The input name was not found in the taxonomy database.\", Warning\n            )\n    return taxid_list\n</code></pre>"}]}